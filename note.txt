
제안 메시지

• Hook Jest Into CI

    in branch protection so PRs can’t merge without passing Jest.

  Extend Coverage After Main/Preload Wiring

만약 당신이 로컬에서만 작업 중이거나 단순히 코드만 돌리는 환경이면, 
이 메시지는 “나중에 이런 흐름을 준비하라”는 권고 수준임

-------------------------------------------------------------------------------------------
Push = 코드 업로드할 때
PR (pull_request) 생성 = 변경(branch)을 main 등에 병합(merge)
-----------------------------------------------------------------------------------------------
on:
  // 내가 코드를 올리고
  push:
    branches: [ main ]
  // main 브렌치로 병합
  pull_request:
    branches: [ main ]

---------------------------------------------------------------------------------------------

# 테스트/검증

🧪 Jest = “코드를 검사하는 도구”
⚙️ CI (지속 통합, Continuous Integration) = “그 도구를 자동으로 돌려주는 로봇 시스템”

| 구분          | Jest                       | CI                                   |
| ----------- | -------------------------- | ------------------------------------   |
| 역할      | 코드가 올바르게 작동하는지 검사(테스트) | 코드가 변경될 때마다 Jest 등 테스트를 자동으로 실행  |
| 누가 실행함? | 개발자가 직접 실행 (`pnpm test`)   | 서버나 GitHub Actions가 자동으로 실행          |
| 실행 시점   | 로컬 개발 중                    | 코드가 push / PR 될 때                    |
| 예시 도구   | Jest, Mocha, Vitest 등      | GitHub Actions, GitLab CI, Jenkins 등 |
| 목표      | 코드 내부 로직의 정확성 보장           | 팀 전체 코드 품질 자동 유지                     |
| 결과      | “이 테스트는 통과/실패했습니다.”        | “전체 프로젝트가 통과/실패했습니다. (병합 가능/불가)”     |


실제 동작 순서  ( CI 체크가 Jest를 돌리는것 )

1. 개발자가 코드를 GitHub에 올림 (push / PR)

2. CI 시스템(GitHub Actions) 이 감지

3. CI가 자동으로 아래 명령들을 실행 👇

pnpm install
pnpm lint
pnpm test   ← 여기서 Jest가 실행됨!

4, Jest가 코드 검사 (테스트 실행)

5. 결과를 CI가 받아서 “✅ 성공 / ❌ 실패” 표시

6. 실패하면 PR 병합 막고, 성공하면 통과!



-----------------------------------------------------------------

pnpm run:electron ->  pnpm dev:desktop -> "concurrently -k \"pnpm dev:web\" \"pnpm desktop:electron\"",

➡️ concurrently 패키지를 이용해서 두 개의 명령을 동시에 실행합니다:

하나는 Next.js 웹 서버 (pnpm dev:web)

다른 하나는 Electron 앱 (pnpm desktop:electron)

-k 옵션은 한쪽 프로세스가 종료되면 모두 종료시키는 옵션입니다.



Phase 5. 시작

session_meta.id 
Codex 세션을 구분하는 유일하고 신뢰할 수 있는 식별자예요.

모든 시스템(파일 스캔, UI 표시, CLI 명령, 테스트)이 이 ID를 기준으로 세션을 식별하고 연결합니다.

즉, 세션의 “진짜 주인공 이름” 역할을 하며,
ID가 없거나 잘못되면 그 세션은 손상된 것으로 간주돼요.

  In short, 'session_meta.id' is the unique, trusted identifier that keeps the scanner,
  renderer, and CLI in sync for every session.



-------------------------------------------------------------------------


*Electron의 IPC

[사용자 UI] <--> [Renderer (Next.js)] <== "IPC" ==> [Main (Electron)] <--> [OS / CLI / File / Network]
